/*******************************************************************************
// Can Driver
*******************************************************************************/

/*******************************************************************************
// Includes
*******************************************************************************/
// Module Includes
#include "CAN_Drv.h" // Driver API
#include "CAN_Drv_Config.h" // Channel enumeration
#include "CAN_Drv_ConfigTable.h" // CAN port configuration
// Platform Includes
#include "Lunar_MessageRouter.h"
#include "Lunar_SoftTimerLib.h"
#include "Platform.h"
// Other Includes
#include "ReportMgr_CAN.h" // Autogenerated CAN messages
#include "xmc_can.h"  // CAN driver
#include "xmc_gpio.h" // GPIO driver header


/*******************************************************************************
// Private Constant Definitions
*******************************************************************************/

// The mask used for 29-bit CAN IDs
#define CAN_EXTENDED_ID_MASK (0x80000000U)

// The minimum function expected by this driver
#define MIN_CAN_FREQUENCY    (12000000U) // 12MHz

// The maximum frequency expected by the this driver
#define MAX_CAN_FREQUENCY    (120000000U) // 120MHz

// Timeout for transmitting a CAN message in milliseconds.
#define CAN_MSG_TX_TIMEOUT_MS          (50U)

// Message object dedicated to message transmission.
#define CAN_TX_MSBOBJ            (CAN_MO0)

// Index of the message object dedicated to message transmission 
#define CAN_TX_MSBOBJ_IDX        (0)

// Message object dedicated to message reception. 
#define CAN_RX_MSBOBJ            (CAN_MO1)

// Index of the message object dedicated to message reception.
#define CAN_RX_MSBOBJ_IDX        (1)

// This defines the maximum length of command data in bytes.
#define COMMAND_DATA_MAX_SIZE (8)

// This defines the maximum length of response data in bytes
#define RESPONSE_DATA_MAX_SIZE (8)

// Address used to identifying messages intended for any device
#define BROADCAST_ADDRESS (0xFFU)


/*******************************************************************************
// Private Type Declarations
*******************************************************************************/

// Struct that defines TX/RX statistics used for debugging and testing
typedef struct
{
    // The number of CAN frames received by the driver
    uint32_t numFramesReceived;
	
    // The number of CAN frames sent by the driver
    uint32_t numFramesSent;
} TxRxStatistics_t;

// Structure to hold buffers and data for each port
typedef struct
{
   // This is the message structure for the message that must be
   // populated and sent to the message router for routing to the
   // destination software module.
   Lunar_MessageRouter_Message_t currentMessage;

   // This buffer is allocated for command data and is pointed to by the
   // command proc message structure.
   uint8_t commandBuffer[COMMAND_DATA_MAX_SIZE];

   // This buffer is allocated for response data and is pointed to by the
   // command proc message structure.
   uint8_t responseBuffer[RESPONSE_DATA_MAX_SIZE];

   /** The address for this device on this port For simplicity in
     * the driver, this initializes to BROADCAST_ADDRESS if
     * addressing is not used                                    
   */
   uint8_t deviceAddress;

   // Stats for transmit and receive data
   TxRxStatistics_t statistics;
} PortData_t;


// This structure holds the private information for this module
typedef struct
{
   // Transmit message object data structure.
   XMC_CAN_MO_t transmitMsgObj;

   // Receive message object data structure.
   XMC_CAN_MO_t receiveMsgObj;

   // Create a status object for each port used
   PortData_t portData;
} CAN_Drv_Status_t;


/*******************************************************************************
// Private Variable Definitions
*******************************************************************************/

// Status structure for this module
static CAN_Drv_Status_t status;


/*******************************************************************************
// Private Function Declarations
*******************************************************************************/

/** Description:
  *    This function initializes the message object used in the CAN driver.
  * Parameters: 
  *    channel :  The given CAN channel to be initialized.  Only a single CAN
  *    node has been tested with this implementation.
  * History:
  *    * 6/18/2021: Function created (EJH)
  *                                                                   
*/
static void CanInit(CAN_Drv_Channel_t channel);

/** Description:
  *    This function checks for a new command in the message object and returns the result.
  * Parameters:
  *    channel :  The message object where the CAN data is to be placed.
  *    The Module ID and Command ID are also populated.
  * Returns:
  *    bool - The result of searching for a new to command to be sent to the message router.
  * Return Value List:
  *    true - A new command was located and placed into the given message object.
  *    false - No command was found.
  * History:
  *    * 6/18/2021: Function created (EJH)
  *
*/
static bool FindNextCommand(Lunar_MessageRouter_Message_t *const message) PLATFORM_NON_NULL;
static void TriggerCommand(Lunar_MessageRouter_Message_t *const message) PLATFORM_NON_NULL;


/*******************************************************************************
// Private Function Implementations
*******************************************************************************/

// Initialize the CAN channel
static void CanInit(const CAN_Drv_Channel_t channel)
{
   // Verify the channel
   if (channel < CAN_DRV_CHANNEL_Count)
   {
      // Channel is valid, store it for easier access
      const CAN_Drv_ConfigItem_t *canConfig = &canConfigTable[channel];

      /* Decide on fCAN frequency. It should be in the 5-120MHz range. according to the
       * datasheet, it must be at least 12MHz if 1 node (channel) is used with up to
       * 16 message objects. This is sufficient for this CAN driver.
       */
      uint32_t canModuleFreqHz = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
      // increase if too low 
      while (canModuleFreqHz < MIN_CAN_FREQUENCY)
      {
         // Double the frequency
         canModuleFreqHz <<= 1;
      }

      // Decrease if too high
      while (canModuleFreqHz > MAX_CAN_FREQUENCY)
      {
         // Cut the frequency in half
         canModuleFreqHz >>= 1;
      }

      // configure CAN module
#if UC_FAMILY == XMC1
		// XMC1000 uses a different clock definition than the XMC4000
      XMC_CAN_Init(CAN, XMC_CAN_CANCLKSRC_MCLK, canModuleFreqHz);		
#else
      // Documentation suggests using the XMC_CAN_InitEx function over the older XMC_CAN_Init
      XMC_CAN_InitEx(CAN, XMC_CAN_CANCLKSRC_FPERI, canModuleFreqHz);
#endif

      // Configure CAN node baud rate
      XMC_CAN_NODE_NOMINAL_BIT_TIME_CONFIG_t baud;
		baud.can_frequency = canModuleFreqHz;
      baud.baudrate = canConfig->channelConfig.baudrate;
      baud.sample_point = canConfig->channelConfig.sample_point;
      baud.sjw = canConfig->channelConfig.sjw;
      XMC_CAN_NODE_NominalBitTimeConfigure(canConfig->channel, &baud);

      // Set CCE and INIT bit NCR for node configuration 
      XMC_CAN_NODE_EnableConfigurationChange(canConfig->channel);
      XMC_CAN_NODE_SetInitBit(canConfig->channel);

      // Configure the transmit message object 
      status.transmitMsgObj.can_mo_ptr = CAN_TX_MSBOBJ;
      status.transmitMsgObj.can_priority = XMC_CAN_ARBITRATION_MODE_IDE_DIR_BASED_PRIO_2;
      /* Set the transmit CAN identifier and negate the bit that configures it as a
       * 29-bit extended CAN identifier.
       */
      uint32_t transmitId = CAN_TX_MSG_ID;
      transmitId &= ~CAN_EXTENDED_ID_MASK;
      if ((CAN_TX_MSG_ID & CAN_EXTENDED_ID_MASK) == 0)
      {
         /* 11-bit standard CAN identifier */
         status.transmitMsgObj.can_identifier = transmitId;
         status.transmitMsgObj.can_id_mask = transmitId;
         status.transmitMsgObj.can_id_mode = XMC_CAN_FRAME_TYPE_STANDARD_11BITS;
         XMC_CAN_MO_AcceptOnlyMatchingIDE(&status.transmitMsgObj);
      }
      else
      {
         /* 29-bit extended CAN identifier */
         status.transmitMsgObj.can_identifier = transmitId;
         status.transmitMsgObj.can_id_mask = transmitId;
         status.transmitMsgObj.can_id_mode = XMC_CAN_FRAME_TYPE_EXTENDED_29BITS;
         XMC_CAN_MO_AcceptOnlyMatchingIDE(&status.transmitMsgObj);
      }

      status.transmitMsgObj.can_data_length = CAN_TX_MAX_DATA;
      for (uint8_t byteIdx = 0; byteIdx < status.transmitMsgObj.can_data_length; byteIdx++)
      {
         status.transmitMsgObj.can_data_byte[byteIdx] = 0;
      }

      status.transmitMsgObj.can_mo_type = XMC_CAN_MO_TYPE_TRANSMSGOBJ;
      XMC_CAN_MO_Config(&status.transmitMsgObj);

      // Allocate transmit message object to the channel 
      XMC_CAN_AllocateMOtoNodeList(CAN, canConfig->channelIndex, CAN_TX_MSBOBJ_IDX);

		
      /* configure the receive message object */
      status.receiveMsgObj.can_mo_ptr = CAN_RX_MSBOBJ;
      status.receiveMsgObj.can_priority = XMC_CAN_ARBITRATION_MODE_IDE_DIR_BASED_PRIO_2;
      /* set the receive CAN identifier and negate the bit that configures it as a
       * 29-bit extended CAN identifier.
       */
      uint32_t receiveId = CAN_RX_MSG_ID;
      receiveId &= ~CAN_EXTENDED_ID_MASK;

      if ((CAN_RX_MSG_ID & CAN_EXTENDED_ID_MASK) == 0)
      {
         /* 11-bit standard CAN identifier */
         status.receiveMsgObj.can_identifier = receiveId;
         status.receiveMsgObj.can_id_mask = receiveId;
         status.receiveMsgObj.can_id_mode = XMC_CAN_FRAME_TYPE_STANDARD_11BITS;
         XMC_CAN_MO_AcceptOnlyMatchingIDE(&status.receiveMsgObj);
      }
      else
      {
         /* 29-bit extended CAN identifier */
         status.receiveMsgObj.can_identifier = receiveId;
         status.receiveMsgObj.can_id_mask = receiveId;
         status.receiveMsgObj.can_id_mode = XMC_CAN_FRAME_TYPE_EXTENDED_29BITS;
         XMC_CAN_MO_AcceptOnlyMatchingIDE(&status.receiveMsgObj);
      }

      status.receiveMsgObj.can_data_length = CAN_RX_MAX_DATA;
      for (uint8_t byteIdx = 0; byteIdx < status.receiveMsgObj.can_data_length; byteIdx++)
      {
         status.receiveMsgObj.can_data_byte[byteIdx] = 0;
      }

      status.receiveMsgObj.can_mo_type = XMC_CAN_MO_TYPE_RECMSGOBJ;
      XMC_CAN_MO_Config(&status.receiveMsgObj);

      /* allocate receive message object to the channel */
      XMC_CAN_AllocateMOtoNodeList(CAN, canConfig->channelIndex, CAN_RX_MSBOBJ_IDX);

      /* reset CCE and INIT bit NCR for node configuration */
      XMC_CAN_NODE_DisableConfigurationChange(canConfig->channel);
      XMC_CAN_NODE_ResetInitBit(canConfig->channel);

      // --- PORT INIT ---
      // Init the port information and buffers
      memset(&status.portData, 0, sizeof(PortData_t));

      // Always start with the broadcast address
      status.portData.deviceAddress = BROADCAST_ADDRESS;
   }


} 

// See if a new CAN message has been received
bool FindNextCommand(Lunar_MessageRouter_Message_t *const message)
{
   // Init to no message found
   bool result = false;

   // Verify the parameter
   if (message != 0)
   {
      // Check if a new message was received
      if ((XMC_CAN_MO_GetStatus(&status.receiveMsgObj) & XMC_CAN_MO_STATUS_RX_PENDING) != 0)
      {
         // Read out and process the newly received data
         if (XMC_CAN_MO_Receive(&status.receiveMsgObj) == XMC_CAN_STATUS_SUCCESS)
         {
            // This message is for us, continue and extract the Module ID
            message->header.moduleID = (uint8_t)(status.receiveMsgObj.can_identifier >> 8U);

            // Move to the next byte for CMD ID
            message->header.commandID = (uint8_t)status.receiveMsgObj.can_identifier;

            // Verify buffer length is sufficient
            if (message->commandParams.maxLength >= status.receiveMsgObj.can_data_length)
            {
               // Store the length in the message object
               message->commandParams.length = status.receiveMsgObj.can_data_length;

               // Store the data in the message object
               for (uint8_t byteIdx = 0; byteIdx < status.receiveMsgObj.can_data_length; byteIdx++)
               {
                  message->commandParams.data[byteIdx] = status.receiveMsgObj.can_data_byte[byteIdx];
                  // Note that a command was found and is ready for processing
                  result = true;
               }
            }

            // Increment the number of frames in the statistics
            // This value will wrap eventually
            status.portData.statistics.numFramesReceived++;
         }

         // Reset the message received flag
         XMC_CAN_MO_ResetStatus(&status.receiveMsgObj, XMC_CAN_MO_RESET_STATUS_RX_PENDING);
      }
   }

   return(result);
}

// Trigger the processing of a single command using the Message Router
static void TriggerCommand(Lunar_MessageRouter_Message_t *const message)
{
	// Verify the parameter
	if (message != 0)
	{      
      //-----------------------------------------------
      // Initialize Command Buffer
      //-----------------------------------------------

      // No command parameters
      message->commandParams.length = 0U;

      //-----------------------------------------------
      // Initialize Response Buffer
      //-----------------------------------------------

      // Setup the buffer for the response
      message->responseParams.data = status.portData.responseBuffer;
      message->responseParams.maxLength = (uint8_t)RESPONSE_DATA_MAX_SIZE;
      message->responseParams.length = 0U;

      //-----------------------------------------------
      // Process Command
      //-----------------------------------------------

      // Process message
      Lunar_MessageRouter_ProcessMessage(message);

      // Increment the number of messages sent
      // Send the response out the serial port.
      CAN_Drv_TransmitPacket(CAN_DRV_CHANNEL_PRIMARY, message->responseParams.data, message->responseParams.length);							
	}
}


/*******************************************************************************
// Public Function Implementations
*******************************************************************************/

// Initialize all configured CAN channels
void CAN_Drv_Init(void)
{

   // Initialize the CAN message objects
   CanInit(CAN_DRV_CHANNEL_PRIMARY);

   // Init the IO pins used for CAN
   XMC_GPIO_CONFIG_t rx_can_config;
   XMC_GPIO_CONFIG_t tx_can_config;

   // Store the channel configuration for easier access
   const CAN_Drv_ConfigItem_t *canConfig = &canConfigTable[CAN_DRV_CHANNEL_PRIMARY];

   /* configure CAN receive pin */
   rx_can_config.mode = canConfig->rxConfig.mode;
   XMC_GPIO_Init(canConfig->rxPin.port, canConfig->rxPin.pin, &rx_can_config);
   /* configure CAN transmit pin */
   tx_can_config.mode = canConfig->txConfig.mode;
   tx_can_config.output_level = canConfig->txConfig.output_level;
#if UC_FAMILY == XMC4
   tx_can_config.output_strength = canConfig->txConfig.output_strength;
#endif	
   XMC_GPIO_Init(canConfig->txPin.port, canConfig->txPin.pin, &tx_can_config);
   /* select CAN Receive Input C (N1_RXDC) to map P1_13 to CAN_NODE1 */
   XMC_CAN_NODE_EnableConfigurationChange(canConfig->channel);
   XMC_CAN_NODE_SetReceiveInput(canConfig->channel, canConfig->input);
   XMC_CAN_NODE_DisableConfigurationChange(canConfig->channel);
}

// Scheduled function to process messages
void CAN_Drv_Update(void)
{
   // Store the message object for easy access
   Lunar_MessageRouter_Message_t *const message = &(status.portData.currentMessage);

	//-----------------------------------------------
	// Initialize Command Buffer
	//-----------------------------------------------

	// Move to the next byte for DATA LENGTH
	// Assign the command buffer
	message->commandParams.data = status.portData.commandBuffer;
	// Set the max size to prevent other modules from overwriting the bounds of the data buffer.
	message->commandParams.maxLength = (uint8_t)COMMAND_DATA_MAX_SIZE;

   // Look for a valid command in the circular RX buffer
   if (FindNextCommand(message))
   {	
		// Init the message to no error
		status.portData.currentMessage.responseCode = LUNAR_MESSAGEROUTER_RESPONSE_CODE_None;

		//-----------------------------------------------
		// Parse Header
		//-----------------------------------------------

		// Populate the command header.  This tells the Message Router
		// how to route the command to the destination module.

		// Addressing is not used, just set address to the broadcast address (0xFF)
		uint8_t destinationAddress = (uint8_t)BROADCAST_ADDRESS;

		// Verify this message is intended for us
		// If addressing is not used, our address will be the broadcast address and the message is accepted
		if ((destinationAddress == BROADCAST_ADDRESS) || (destinationAddress == status.portData.deviceAddress))
		{
			// Extract everything and verify the CRC
			
			// Module and Command were set when CAN message was received

			//-----------------------------------------------
			// Initialize Response Buffer
			//-----------------------------------------------

			// Setup the buffer for the response
			message->responseParams.data = status.portData.responseBuffer;
			message->responseParams.maxLength = (uint8_t)RESPONSE_DATA_MAX_SIZE;
			message->responseParams.length = 0U;

			//-----------------------------------------------
			// Process Command
			//-----------------------------------------------

			// Increment the number of messages received since this command will at least generate some sort of response message
			status.portData.statistics.numFramesReceived++;

			// Process message
			Lunar_MessageRouter_ProcessMessage(message);
		}
   }

   // Trigger an outgoing message
   //-----------------------------------------------
   // Set Header
   //-----------------------------------------------
   message->header.moduleID = (uint8_t)(CAN_TX_MSG_ID >> 8U);
   message->header.commandID = (uint8_t)(CAN_TX_MSG_ID);

   //-----------------------------------------------
   // Process Command
   //-----------------------------------------------
   TriggerCommand(message);
}


// Send a single CAN packet
void CAN_Drv_TransmitPacket(const CAN_Drv_Channel_t channel, uint8_t *const data, const uint8_t length)
{
	// Verify the channel index
	if (channel < CAN_DRV_CHANNEL_Count)
	{
		// Copy message data
		status.transmitMsgObj.can_data_length = length;
		for (uint8_t byteIdx = 0; byteIdx < status.transmitMsgObj.can_data_length; byteIdx++)
		{
			status.transmitMsgObj.can_data_byte[byteIdx] = data[byteIdx];
		}

		/* update the message object */
		XMC_CAN_MO_UpdateData(&status.transmitMsgObj);
		/* reset the message object's transmit pending flag */
		XMC_CAN_MO_ResetStatus(&status.transmitMsgObj, XMC_CAN_MO_RESET_STATUS_TX_PENDING);
		/* submit message for transmission */
		XMC_CAN_MO_Transmit(&status.transmitMsgObj);

		/* set timeout time to wait for transmission completion */
		Lunar_SoftTimerLib_Timer_t timer;

		Lunar_SoftTimerLib_Init(&timer);
		Lunar_SoftTimerLib_StartTimer(&timer, CAN_MSG_TX_TIMEOUT_MS);
		
		// Wait for transmit completion 
		// Note that this will need to be moved to a non-blocking method
		while ((XMC_CAN_MO_GetStatus(&status.transmitMsgObj) & XMC_CAN_MO_STATUS_TX_PENDING) != 0)
		{
			// Break loop upon timeout. This would indicate a hardware failure or no other
			// nodes connected to the bus.
			if (Lunar_SoftTimerLib_IsTimerExpired(&timer))
			{
				break;
			}
		}
		
		// Increment the sent value in statistics
		// Note this value is expected to wrap eventually
		status.portData.statistics.numFramesSent++;
	}	
}

// Receive a single CAN packet, if available
bool CAN_Drv_ReceivePacket(const CAN_Drv_Channel_t channel, uint8_t *const data, uint8_t *const length)
{
   bool result = false;

	// Verify the channel index
	if (channel < CAN_DRV_CHANNEL_Count)
	{
		// Check if a new message was received
		if ((XMC_CAN_MO_GetStatus(&status.receiveMsgObj) & XMC_CAN_MO_STATUS_RX_PENDING) != 0)
		{
			// Read out and process the newly received data 
			if (XMC_CAN_MO_Receive(&status.receiveMsgObj) == XMC_CAN_STATUS_SUCCESS)
			{
				// Store the length in the given location
				*length = status.receiveMsgObj.can_data_length;
				for (uint8_t byteIdx = 0; byteIdx < status.receiveMsgObj.can_data_length; byteIdx++)
				{
					data[byteIdx] = status.receiveMsgObj.can_data_byte[byteIdx];
					result = true;
				}
			}

			// Reset the message received flag
			XMC_CAN_MO_ResetStatus(&status.receiveMsgObj, XMC_CAN_MO_RESET_STATUS_RX_PENDING);
			
			// Increment the number of messages received since this command will at least generate some sort of response message
			status.portData.statistics.numFramesReceived++;		
		}
	}

   return(result);
} 


/*******************************************************************************
// Interrupt Handlers
*******************************************************************************/


